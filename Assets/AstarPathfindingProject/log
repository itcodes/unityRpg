diff --git a/Assets/AstarPathfindingProject/Core/AstarData.cs b/Assets/AstarPathfindingProject/Core/AstarData.cs
index 08b38cd..3533348 100644
--- a/Assets/AstarPathfindingProject/Core/AstarData.cs
+++ b/Assets/AstarPathfindingProject/Core/AstarData.cs
@@ -24,7 +24,7 @@ namespace Pathfinding {
 		/** Shortcut to AstarPath.active */
 		public AstarPath active {
 			get {
-				return AstarPath.active;
+				return AstarPath.newActive;
 			}
 		}
 
@@ -171,7 +171,7 @@ namespace Pathfinding {
 		/** Load from data from #file_cachedStartup */
 		public void LoadFromCache () {
 			
-			AstarPath.active.BlockUntilPathQueueBlocked();
+			AstarPath.newActive.BlockUntilPathQueueBlocked();
 			if (file_cachedStartup != null) {
 				var bytes = file_cachedStartup.bytes;
 				DeserializeGraphs (bytes);
@@ -205,7 +205,7 @@ namespace Pathfinding {
 		  * A similar function exists in the AstarPathEditor.cs script to save additional info */
 		public byte[] SerializeGraphs (Pathfinding.Serialization.SerializeSettings settings, out uint checksum) {
 			
-			AstarPath.active.BlockUntilPathQueueBlocked();
+			AstarPath.newActive.BlockUntilPathQueueBlocked();
 			
 			Pathfinding.Serialization.AstarSerializer sr = new Pathfinding.Serialization.AstarSerializer(this, settings);
 			sr.OpenSerialize();
@@ -256,7 +256,7 @@ namespace Pathfinding {
 		  */
 		public void DeserializeGraphs (byte[] bytes) {
 			
-			AstarPath.active.BlockUntilPathQueueBlocked();
+			AstarPath.newActive.BlockUntilPathQueueBlocked();
 			
 			try {
 				if (bytes != null) {
@@ -287,7 +287,7 @@ namespace Pathfinding {
 		  */
 		public void DeserializeGraphsAdditive (byte[] bytes) {
 			
-			AstarPath.active.BlockUntilPathQueueBlocked();
+			AstarPath.newActive.BlockUntilPathQueueBlocked();
 			
 			try {
 				if (bytes != null) {
@@ -505,7 +505,7 @@ namespace Pathfinding {
 		public void AddGraph (NavGraph graph) {
 			
 			// Make sure to not interfere with pathfinding
-			AstarPath.active.BlockUntilPathQueueBlocked();
+			AstarPath.newActive.BlockUntilPathQueueBlocked();
 			
 			//Try to fill in an empty position
 			for (int i=0;i<graphs.Length;i++) {
@@ -579,7 +579,7 @@ namespace Pathfinding {
 			
 			if (node == null) return null;
 			
-			AstarPath script = AstarPath.active;
+			AstarPath script = AstarPath.newActive;
 			
 			if (script == null) return null;
 			
diff --git a/Assets/AstarPathfindingProject/Core/AstarPath.cs b/Assets/AstarPathfindingProject/Core/AstarPath.cs
index 5243578..888ed15 100644
--- a/Assets/AstarPathfindingProject/Core/AstarPath.cs
+++ b/Assets/AstarPathfindingProject/Core/AstarPath.cs
@@ -81,7 +81,7 @@ public class AstarPath : MonoBehaviour {
 #if UNITY_4_6 || UNITY_4_3
 	public static new AstarPath active;
 #else
-	public static AstarPath active;
+	public static AstarPath newActive;
 #endif
 
 	/** Shortcut to Pathfinding.AstarData.graphs */
@@ -616,10 +616,10 @@ public class AstarPath : MonoBehaviour {
 	 * \see AstarPath.GetTagNames
 	 */
 	public static string[] FindTagNames () {
-		if (active != null) return active.GetTagNames ();
+		if (newActive != null) return newActive.GetTagNames ();
 		else {
 			AstarPath a = GameObject.FindObjectOfType (typeof (AstarPath)) as AstarPath;
-			if (a != null) { active = a; return a.GetTagNames (); }
+			if (a != null) { newActive = a; return a.GetTagNames (); }
 			else {
 				return new string[1] {"There is no AstarPath component in the scene"};
 			}
@@ -660,9 +660,9 @@ public class AstarPath : MonoBehaviour {
 	private void OnDrawGizmos () {
 		AstarProfiler.StartProfile ("OnDrawGizmos");
 		
-		if (active == null) {
-			active = this;
-		} else if (active != this) {
+		if (newActive == null) {
+			newActive = this;
+		} else if (newActive != this) {
 			return;
 		}
 		
@@ -680,7 +680,7 @@ public class AstarPath : MonoBehaviour {
 				if (graphs[i] != null && graphs[i].drawGizmos) {
 					graphs[i].GetNodes (delegate (GraphNode node) {
 
-						if (!AstarPath.active.showSearchTree || debugPathData == null || NavGraph.InSearchTree(node,debugPath)) {
+						if (!AstarPath.newActive.showSearchTree || debugPathData == null || NavGraph.InSearchTree(node,debugPath)) {
 							var rnode = debugPathData != null ? debugPathData.GetPathNode(node) : null;
 							if (rnode != null || debugMode == GraphDebugMode.Penalty) {
 								switch (debugMode) {
@@ -778,24 +778,24 @@ public class AstarPath : MonoBehaviour {
 #line hidden
 	/** Logs a string while taking into account #logPathResults */
 	private static void AstarLog (string s) {
-		if (System.Object.ReferenceEquals(active,null)) {
+		if (System.Object.ReferenceEquals(newActive,null)) {
 			Debug.Log ("No AstarPath object was found : "+s);
 			return;
 		}
 		
-		if (active.logPathResults != PathLog.None && active.logPathResults != PathLog.OnlyErrors) {
+		if (newActive.logPathResults != PathLog.None && newActive.logPathResults != PathLog.OnlyErrors) {
 			Debug.Log (s);
 		}
 	}
 	
 	/** Logs an error string while taking into account #logPathResults */
 	private static void AstarLogError (string s) {
-		if (active == null) {
+		if (newActive == null) {
 			Debug.Log ("No AstarPath object was found : "+s);
 			return;
 		}
 		
-		if (active.logPathResults != PathLog.None) {
+		if (newActive.logPathResults != PathLog.None) {
 			Debug.LogError (s);
 		}
 	}
@@ -1161,7 +1161,7 @@ public class AstarPath : MonoBehaviour {
 		
 			foreach (IUpdatableGraph g in astarData.GetUpdateableGraphs ()) {
 				NavGraph gr = g as NavGraph;
-				if (ob.nnConstraint == null || ob.nnConstraint.SuitableGraph (active.astarData.GetGraphIndex (gr),gr)) {
+				if (ob.nnConstraint == null || ob.nnConstraint.SuitableGraph (newActive.astarData.GetGraphIndex (gr),gr)) {
 					GUOSingle aguo = new GUOSingle ();
 					aguo.order = GraphUpdateOrder.GraphUpdate;
 					aguo.obj = ob;
@@ -1428,7 +1428,7 @@ public class AstarPath : MonoBehaviour {
 	 */
 	public void Awake () {
 		//Very important to set this. Ensures the singleton pattern holds
-		active = this;
+		newActive = this;
 		
 		if (FindObjectsOfType (typeof(AstarPath)).Length > 1) {
 			Debug.LogError ("You should NOT have more than one AstarPath component in the scene at any time.\n" +
@@ -1511,7 +1511,7 @@ public class AstarPath : MonoBehaviour {
 	 */
 	public void VerifyIntegrity () {
 		
-		if (active != this) {
+		if (newActive != this) {
 			throw new System.Exception ("Singleton pattern broken. Make sure you only have one AstarPath object in the scene");
 		}
 		
@@ -1538,7 +1538,7 @@ public class AstarPath : MonoBehaviour {
 	/** Makes sure #active is set to this object and that #astarData is not null.
 	 * Also calls OnEnable for the #colorSettings and initializes astarData.userConnections if it wasn't initialized before */
 	public void SetUpReferences () {
-		active = this;
+		newActive = this;
 		if (astarData == null) {
 			astarData = new AstarData ();
 		}
@@ -1602,7 +1602,7 @@ public class AstarPath : MonoBehaviour {
 		if (logPathResults == PathLog.Heavy)
 			Debug.Log ("+++ AstarPath Component Destroyed - Cleaning Up Pathfinding Data +++");
 		
-		if ( active != this ) return;
+		if ( newActive != this ) return;
 		
 #if ASTARDEBUG
 		System.Diagnostics.Stopwatch watch = new System.Diagnostics.Stopwatch ();
@@ -1687,7 +1687,7 @@ public class AstarPath : MonoBehaviour {
 		
 		PathsCompleted = 0;
 		
-		active = null;
+		newActive = null;
 		
 	}
 	
@@ -2205,13 +2205,13 @@ Debug.Log ("Scanning... " + progress.description + " - " + (progress.progress*10
 	 */
 	public static void WaitForPath (Path p) {
 		
-		if (active == null)
+		if (newActive == null)
 			throw new System.Exception ("Pathfinding is not correctly initialized in this scene (yet?). " +
 				"AstarPath.active is null.\nDo not call this function in Awake");
 		
 		if (p == null) throw new System.ArgumentNullException ("Path must not be null");
 		
-		if (active.pathQueue.IsTerminating) return;
+		if (newActive.pathQueue.IsTerminating) return;
 		
 		if (p.GetState () == PathState.Created){
 			throw new System.Exception ("The specified path has not been started yet.");
@@ -2227,30 +2227,30 @@ Debug.Log ("Scanning... " + progress.description + " - " + (progress.progress*10
 			if (IsUsingMultithreading) {
 				
 				while (p.GetState() < PathState.ReturnQueue) {
-					if (active.pathQueue.IsTerminating) {
+					if (newActive.pathQueue.IsTerminating) {
 						waitForPathDepth--;
 						throw new System.Exception ("Pathfinding Threads seems to have crashed.");
 					}
 					
 					//Wait for threads to calculate paths
 					Thread.Sleep(1);
-					active.PerformBlockingActions();
+					newActive.PerformBlockingActions();
 				}
 			} else {
 				while (p.GetState() < PathState.ReturnQueue) {
-					if (active.pathQueue.IsEmpty && p.GetState () != PathState.Processing) {
+					if (newActive.pathQueue.IsEmpty && p.GetState () != PathState.Processing) {
 						waitForPathDepth--;
 						throw new System.Exception ("Critical error. Path Queue is empty but the path state is '" + p.GetState() + "'");
 					}
 					
 					//Calculate some paths
 					threadEnumerator.MoveNext ();
-					active.PerformBlockingActions();
+					newActive.PerformBlockingActions();
 				}
 			}
 		}
 		
-		active.ReturnPaths (false);
+		newActive.ReturnPaths (false);
 		
 		waitForPathDepth--;
 	}
@@ -2300,19 +2300,19 @@ AstarPath.RegisterSafeUpdate (delegate () {
 			return;
 		}
 		
-		if (active.pathQueue.AllReceiversBlocked) {
+		if (newActive.pathQueue.AllReceiversBlocked) {
 			// We need to lock here since we cannot be sure that this is the Unity Thread
 			// and therefore we cannot be sure that some other thread will not unblock the queue while we are processing the callback
-			active.pathQueue.Lock();
+			newActive.pathQueue.Lock();
 			try {
 				//Check again
-				if (active.pathQueue.AllReceiversBlocked) {
+				if (newActive.pathQueue.AllReceiversBlocked) {
 					callback ();
 					return;
 				}
 				// If that check failed, it will fall back to the code below
 			} finally {
-				active.pathQueue.Unlock();
+				newActive.pathQueue.Unlock();
 			}
 		}
 		
@@ -2322,13 +2322,13 @@ AstarPath.RegisterSafeUpdate (delegate () {
 			OnThreadSafeCallback += callback;
 		}
 		//Block path queue so that the above callbacks may be called
-		active.pathQueue.Block();
+		newActive.pathQueue.Block();
 		
 	}
 
 	/** Blocks the path queue so that e.g work items can be performed */
 	private static void InterruptPathfinding () {
-		active.pathQueue.Block();
+		newActive.pathQueue.Block();
 	}
 	
 	/** Puts the Path in queue for calculation.
@@ -2342,7 +2342,7 @@ AstarPath.RegisterSafeUpdate (delegate () {
 	  */
 	public static void StartPath (Path p, bool pushToFront = false) {
 		
-		if (System.Object.ReferenceEquals (active, null)) {
+		if (System.Object.ReferenceEquals (newActive, null)) {
 			Debug.LogError ("There is no AstarPath object in the scene");
 			return;
 		}
@@ -2352,13 +2352,13 @@ AstarPath.RegisterSafeUpdate (delegate () {
 				"Make sure you are not requesting the same path twice");
 		}
 		
-		if (active.pathQueue.IsTerminating) {
+		if (newActive.pathQueue.IsTerminating) {
 			p.Error ();
 			p.LogError ("No new paths are accepted");
 			return;
 		}
 		
-		if (active.graphs == null || active.graphs.Length == 0) {
+		if (newActive.graphs == null || newActive.graphs.Length == 0) {
 			Debug.LogError ("There are no graphs in the scene");
 			p.Error ();
 			p.LogError ("There are no graphs in the scene");
@@ -2366,15 +2366,15 @@ AstarPath.RegisterSafeUpdate (delegate () {
 			return;
 		}
 		
-		p.Claim (active);
+		p.Claim (newActive);
 		
 		
 		//Will increment to PathQueue
 		p.AdvanceState (PathState.PathQueue);
 		if (pushToFront) {
-			active.pathQueue.PushFront (p);
+			newActive.pathQueue.PushFront (p);
 		} else {
-			active.pathQueue.Push (p);
+			newActive.pathQueue.Push (p);
 		}
 	}
 	
@@ -2685,7 +2685,7 @@ AstarPath.RegisterSafeUpdate (delegate () {
 				"threadInfo is an argument to the thread functions");
 		
 		//Max number of ticks before yielding/sleeping
-		long maxTicks = (long)(active.maxFrameTime*10000);
+		long maxTicks = (long)(newActive.maxFrameTime*10000);
 		long targetTick = System.DateTime.UtcNow.Ticks + maxTicks;
 		
 		while (true) {
@@ -2721,7 +2721,7 @@ AstarPath.RegisterSafeUpdate (delegate () {
 			
 			//Max number of ticks we are allowed to continue working in one run
 			//One tick is 1/10000 of a millisecond
-			maxTicks = (long)(active.maxFrameTime*10000);
+			maxTicks = (long)(newActive.maxFrameTime*10000);
 			
 			p.PrepareBase (runData);
 			
@@ -2752,7 +2752,7 @@ AstarPath.RegisterSafeUpdate (delegate () {
 			if (!p.IsDone()) {
 				
 				//For debug uses, we set the last computed path to p, so we can view debug info on it in the editor (scene view).
-				active.debugPath = p;
+				newActive.debugPath = p;
 				
 				//Initialize the path, now ready to begin search
 				AstarProfiler.StartProfile ("Path Initialize");
@@ -2811,7 +2811,7 @@ AstarPath.RegisterSafeUpdate (delegate () {
 			
 			//Log path results
 			AstarProfiler.StartProfile ("Log Path Results");
-			active.LogPathResults (p);
+			newActive.LogPathResults (p);
 			AstarProfiler.EndProfile ();
 			
 			AstarProfiler.EndFastProfile(8);
diff --git a/Assets/AstarPathfindingProject/Core/GraphUpdateScene.cs b/Assets/AstarPathfindingProject/Core/GraphUpdateScene.cs
index 57fd20c..5226736 100644
--- a/Assets/AstarPathfindingProject/Core/GraphUpdateScene.cs
+++ b/Assets/AstarPathfindingProject/Core/GraphUpdateScene.cs
@@ -235,7 +235,7 @@ namespace Pathfinding {
 		 */
 		public void Apply () {
 			
-			if (AstarPath.active == null) {
+			if (AstarPath.newActive == null) {
 				Debug.LogError ("There is no AstarPath object in the scene");
 				return;
 			}
@@ -293,7 +293,7 @@ namespace Pathfinding {
 			guo.setTag = setTag;
 	#endif
 			
-			AstarPath.active.UpdateGraphs (guo);
+			AstarPath.newActive.UpdateGraphs (guo);
 		}
 		
 		/** Draws some gizmos */
diff --git a/Assets/AstarPathfindingProject/Core/Misc/AnimationLink.cs b/Assets/AstarPathfindingProject/Core/Misc/AnimationLink.cs
index 4c09e94..9e3532d 100644
--- a/Assets/AstarPathfindingProject/Core/Misc/AnimationLink.cs
+++ b/Assets/AstarPathfindingProject/Core/Misc/AnimationLink.cs
@@ -22,7 +22,7 @@ namespace Pathfinding {
 			
 			public string name {
 				get {
-					return clip != null ? clip.name : "";
+					return clip != null ? clip.newName : "";
 				}
 			}
 			
@@ -32,7 +32,7 @@ namespace Pathfinding {
 			int childCount = tr.childCount;
 			for (int i=0;i<childCount;i++) {
 				Transform ch = tr.GetChild(i);
-				if (ch.name == name) return ch;
+				if (ch.newName == name) return ch;
 				else {
 					Transform rec = SearchRec(ch,name);
 					if (rec != null) return rec;
@@ -56,7 +56,7 @@ namespace Pathfinding {
 			if (anim == null) anim = ob.AddComponent<Animation>();
 			
 			for (int i=0;i<sequence.Length;i++) {
-				anim.AddClip(sequence[i].clip, sequence[i].clip.name);
+				anim.AddClip(sequence[i].clip, sequence[i].clip.newName);
 			}
 			
 			Vector3 prevOffset = Vector3.zero;
@@ -71,11 +71,11 @@ namespace Pathfinding {
 					return;
 				}
 				
-				anim[c.clip.name].enabled = true;
-				anim[c.clip.name].weight = 1;
+				anim[c.clip.newName].enabled = true;
+				anim[c.clip.newName].weight = 1;
 				
 				for (int repeat=0;repeat < c.loopCount; repeat++) {
-					anim[c.clip.name].normalizedTime = 0;
+					anim[c.clip.newName].normalizedTime = 0;
 					anim.Sample();
 					Vector3 soffset = root.position - transform.position;
 					
@@ -87,21 +87,21 @@ namespace Pathfinding {
 					
 					for (int t=0;t<=20;t++) {
 						float tf = t/20.0f;
-						anim[c.clip.name].normalizedTime = tf;
+						anim[c.clip.newName].normalizedTime = tf;
 						anim.Sample();
 						Vector3 tmp = position + (root.position-transform.position) + c.velocity*tf*c.clip.length;
 						trace.Add (tmp);
 					}
 					position = position + c.velocity*1*c.clip.length;
 					
-					anim[c.clip.name].normalizedTime = 1;
+					anim[c.clip.newName].normalizedTime = 1;
 					anim.Sample();
 					Vector3 eoffset = root.position - transform.position;
 					prevOffset = eoffset;
 				}
 				
-				anim[c.clip.name].enabled = false;
-				anim[c.clip.name].weight = 0;
+				anim[c.clip.newName].enabled = false;
+				anim[c.clip.newName].weight = 0;
 			}
 			
 			position += prevOffset - firstOffset;
diff --git a/Assets/AstarPathfindingProject/Core/Misc/AstarDebugger.cs b/Assets/AstarPathfindingProject/Core/Misc/AstarDebugger.cs
index 3d7055c..2ed90bd 100644
--- a/Assets/AstarPathfindingProject/Core/Misc/AstarDebugger.cs
+++ b/Assets/AstarPathfindingProject/Core/Misc/AstarDebugger.cs
@@ -301,7 +301,7 @@ public class AstarDebugger : MonoBehaviour {
 			}
 			
 			if (showPathProfile) {
-				AstarPath astar = AstarPath.active;
+				AstarPath astar = AstarPath.newActive;
 				
 				text.AppendLine ();
 				
diff --git a/Assets/AstarPathfindingProject/Core/Misc/NodeLink.cs b/Assets/AstarPathfindingProject/Core/Misc/NodeLink.cs
index e768d73..650a7f0 100644
--- a/Assets/AstarPathfindingProject/Core/Misc/NodeLink.cs
+++ b/Assets/AstarPathfindingProject/Core/Misc/NodeLink.cs
@@ -34,10 +34,10 @@ namespace Pathfinding {
 	
 		public override void OnPostScan () {
 			
-			if (AstarPath.active.isScanning) {
+			if (AstarPath.newActive.isScanning) {
 				InternalOnPostScan ();
 			} else {
-				AstarPath.active.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
+				AstarPath.newActive.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
 					InternalOnPostScan ();
 					return true;
 				}));
@@ -49,8 +49,8 @@ namespace Pathfinding {
 		}
 	
 		public override void OnGraphsPostUpdate () {
-			if (!AstarPath.active.isScanning) {
-				AstarPath.active.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
+			if (!AstarPath.newActive.isScanning) {
+				AstarPath.newActive.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
 					InternalOnPostScan ();
 					return true;
 				}));
@@ -58,10 +58,10 @@ namespace Pathfinding {
 		}
 	
 		public virtual void Apply () {
-			if (Start == null || End == null || AstarPath.active == null) return;
+			if (Start == null || End == null || AstarPath.newActive == null) return;
 			
-			GraphNode startNode = AstarPath.active.GetNearest (Start.position).node;
-			GraphNode endNode = AstarPath.active.GetNearest (End.position).node;
+			GraphNode startNode = AstarPath.newActive.GetNearest (Start.position).node;
+			GraphNode endNode = AstarPath.newActive.GetNearest (End.position).node;
 			
 			if (startNode == null || endNode == null) return;
 			
diff --git a/Assets/AstarPathfindingProject/Core/Misc/NodeLink2.cs b/Assets/AstarPathfindingProject/Core/Misc/NodeLink2.cs
index 3443520..7fa043b 100644
--- a/Assets/AstarPathfindingProject/Core/Misc/NodeLink2.cs
+++ b/Assets/AstarPathfindingProject/Core/Misc/NodeLink2.cs
@@ -58,10 +58,10 @@ namespace Pathfinding {
 		
 		public override void OnPostScan () {
 			
-			if (AstarPath.active.isScanning) {
+			if (AstarPath.newActive.isScanning) {
 				InternalOnPostScan ();
 			} else {
-				AstarPath.active.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
+				AstarPath.newActive.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
 					InternalOnPostScan ();
 					return true;
 				}));
@@ -73,8 +73,8 @@ namespace Pathfinding {
 			if ( EndTransform == null || StartTransform == null ) return;
 
 #if !ASTAR_NO_POINT_GRAPH
-			if ( AstarPath.active.astarData.pointGraph == null ) {
-				AstarPath.active.astarData.AddGraph ( new PointGraph () );
+			if ( AstarPath.newActive.astarData.pointGraph == null ) {
+				AstarPath.newActive.astarData.AddGraph ( new PointGraph () );
 			}
 #endif
 
@@ -91,8 +91,8 @@ namespace Pathfinding {
 	
 #if !ASTAR_NO_POINT_GRAPH	
 			//Get nearest nodes from the first point graph, assuming both start and end transforms are nodes
-			startNode = AstarPath.active.astarData.pointGraph.AddNode ( (Int3)StartTransform.position );//AstarPath.active.astarData.pointGraph.GetNearest(StartTransform.position).node as PointNode;
-			endNode = AstarPath.active.astarData.pointGraph.AddNode ( (Int3)EndTransform.position ); //AstarPath.active.astarData.pointGraph.GetNearest(EndTransform.position).node as PointNode;
+			startNode = AstarPath.newActive.astarData.pointGraph.AddNode ( (Int3)StartTransform.position );//AstarPath.active.astarData.pointGraph.GetNearest(StartTransform.position).node as PointNode;
+			endNode = AstarPath.newActive.astarData.pointGraph.AddNode ( (Int3)EndTransform.position ); //AstarPath.active.astarData.pointGraph.GetNearest(EndTransform.position).node as PointNode;
 #else
 			throw new System.Exception ("Point graph is not included. Check your A* optimization settings.");
 #endif
@@ -114,7 +114,7 @@ namespace Pathfinding {
 			
 		public override void OnGraphsPostUpdate () {
 			//if (connectedNode1 != null && connectedNode2 != null) {
-			if (!AstarPath.active.isScanning) {
+			if (!AstarPath.newActive.isScanning) {
 				
 				if (connectedNode1 != null && connectedNode1.Destroyed) {
 					connectedNode1 = null;
@@ -137,7 +137,7 @@ namespace Pathfinding {
 			base.OnEnable();
 			
 #if !ASTAR_NO_POINT_GRAPH
-			if (AstarPath.active != null && AstarPath.active.astarData != null && AstarPath.active.astarData.pointGraph != null) {
+			if (AstarPath.newActive != null && AstarPath.newActive.astarData != null && AstarPath.newActive.astarData.pointGraph != null) {
 				OnGraphsPostUpdate ();
 			}
 #endif
@@ -181,8 +181,8 @@ namespace Pathfinding {
 		void ContextApplyForce () {
 			if (Application.isPlaying) {
 				Apply ( true );
-				if ( AstarPath.active != null ) {
-					AstarPath.active.FloodFill ();
+				if ( AstarPath.newActive != null ) {
+					AstarPath.newActive.FloodFill ();
 				}
 			}
 		}
@@ -207,13 +207,13 @@ namespace Pathfinding {
 			endNode.AddConnection(startNode, cost);
 			
 			if (connectedNode1 == null || forceNewCheck) {
-				NNInfo n1 = AstarPath.active.GetNearest(StartTransform.position, nn);
+				NNInfo n1 = AstarPath.newActive.GetNearest(StartTransform.position, nn);
 				connectedNode1 = n1.node as MeshNode;
 				clamped1 = n1.clampedPosition;
 			}
 			
 			if (connectedNode2 == null || forceNewCheck) {
-				NNInfo n2 = AstarPath.active.GetNearest(EndTransform.position, nn);
+				NNInfo n2 = AstarPath.newActive.GetNearest(EndTransform.position, nn);
 				connectedNode2 = n2.node as MeshNode;
 				clamped2 = n2.clampedPosition;
 			}
diff --git a/Assets/AstarPathfindingProject/Core/Misc/NodeLink3.cs b/Assets/AstarPathfindingProject/Core/Misc/NodeLink3.cs
index f9509c1..4f1d919 100644
--- a/Assets/AstarPathfindingProject/Core/Misc/NodeLink3.cs
+++ b/Assets/AstarPathfindingProject/Core/Misc/NodeLink3.cs
@@ -108,10 +108,10 @@ namespace Pathfinding {
 		
 		public override void OnPostScan () {
 			
-			if (AstarPath.active.isScanning) {
+			if (AstarPath.newActive.isScanning) {
 				InternalOnPostScan ();
 			} else {
-				AstarPath.active.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
+				AstarPath.newActive.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
 					InternalOnPostScan ();
 					return true;
 				}));
@@ -121,14 +121,14 @@ namespace Pathfinding {
 		public void InternalOnPostScan () {
 			
 #if !ASTAR_NO_POINT_GRAPH
-			if ( AstarPath.active.astarData.pointGraph == null ) {
-				AstarPath.active.astarData.AddGraph ( new PointGraph () );
+			if ( AstarPath.newActive.astarData.pointGraph == null ) {
+				AstarPath.newActive.astarData.AddGraph ( new PointGraph () );
 			}
 			
 			//Get nearest nodes from the first point graph, assuming both start and end transforms are nodes
-			startNode = AstarPath.active.astarData.pointGraph.AddNode ( new NodeLink3Node(AstarPath.active), (Int3)StartTransform.position );//AstarPath.active.astarData.pointGraph.GetNearest(StartTransform.position).node as PointNode;
+			startNode = AstarPath.newActive.astarData.pointGraph.AddNode ( new NodeLink3Node(AstarPath.newActive), (Int3)StartTransform.position );//AstarPath.active.astarData.pointGraph.GetNearest(StartTransform.position).node as PointNode;
 			startNode.link = this;
-			endNode = AstarPath.active.astarData.pointGraph.AddNode ( new NodeLink3Node(AstarPath.active), (Int3)EndTransform.position ); //AstarPath.active.astarData.pointGraph.GetNearest(EndTransform.position).node as PointNode;
+			endNode = AstarPath.newActive.astarData.pointGraph.AddNode ( new NodeLink3Node(AstarPath.newActive), (Int3)EndTransform.position ); //AstarPath.active.astarData.pointGraph.GetNearest(EndTransform.position).node as PointNode;
 			endNode.link = this;
 #else
 			throw new System.Exception ("Point graphs are not included. Check your A* Optimization settings.");
@@ -150,7 +150,7 @@ namespace Pathfinding {
 			
 		public override void OnGraphsPostUpdate () {
 			//if (connectedNode1 != null && connectedNode2 != null) {
-			if (!AstarPath.active.isScanning) {
+			if (!AstarPath.newActive.isScanning) {
 				
 				if (connectedNode1 != null && connectedNode1.Destroyed) {
 					connectedNode1 = null;
@@ -172,7 +172,7 @@ namespace Pathfinding {
 			base.OnEnable();
 			
 #if !ASTAR_NO_POINT_GRAPH
-			if (AstarPath.active != null && AstarPath.active.astarData != null && AstarPath.active.astarData.pointGraph != null) {
+			if (AstarPath.newActive != null && AstarPath.newActive.astarData != null && AstarPath.newActive.astarData.pointGraph != null) {
 				OnGraphsPostUpdate ();
 			}
 #endif
@@ -209,8 +209,8 @@ namespace Pathfinding {
 		void ContextApplyForce () {
 			if (Application.isPlaying) {
 				Apply ( true );
-				if ( AstarPath.active != null ) {
-					AstarPath.active.FloodFill ();
+				if ( AstarPath.newActive != null ) {
+					AstarPath.newActive.FloodFill ();
 				}
 			}
 		}
@@ -228,7 +228,7 @@ namespace Pathfinding {
 			bool same = true;
 			
 			if (true) {
-				NNInfo n1 = AstarPath.active.GetNearest(StartTransform.position, nn);
+				NNInfo n1 = AstarPath.newActive.GetNearest(StartTransform.position, nn);
 				same &= n1.node == connectedNode1 && n1.node != null;
 				connectedNode1 = n1.node as MeshNode;
 				clamped1 = n1.clampedPosition;
@@ -236,7 +236,7 @@ namespace Pathfinding {
 			}
 			
 			if (true) {
-				NNInfo n2 = AstarPath.active.GetNearest(EndTransform.position, nn);
+				NNInfo n2 = AstarPath.newActive.GetNearest(EndTransform.position, nn);
 				same &= n2.node == connectedNode2 && n2.node != null;
 				connectedNode2 = n2.node as MeshNode;
 				clamped2 = n2.clampedPosition;
diff --git a/Assets/AstarPathfindingProject/Core/Nodes/GraphNode.cs b/Assets/AstarPathfindingProject/Core/Nodes/GraphNode.cs
index 489226b..1c46bcd 100644
--- a/Assets/AstarPathfindingProject/Core/Nodes/GraphNode.cs
+++ b/Assets/AstarPathfindingProject/Core/Nodes/GraphNode.cs
@@ -71,8 +71,8 @@ namespace Pathfinding {
 			
 			ClearConnections(true);
 			
-			if (AstarPath.active != null) {
-				AstarPath.active.DestroyNode(this);
+			if (AstarPath.newActive != null) {
+				AstarPath.newActive.DestroyNode(this);
 			}
 			nodeIndex = -1;
 			//System.Console.WriteLine ("~");
diff --git a/Assets/AstarPathfindingProject/Core/Path.cs b/Assets/AstarPathfindingProject/Core/Path.cs
index 67851ee..76884d7 100644
--- a/Assets/AstarPathfindingProject/Core/Path.cs
+++ b/Assets/AstarPathfindingProject/Core/Path.cs
@@ -269,12 +269,12 @@ yield return StartCoroutine (p.WaitForPath ());
 			switch (heuristic) {
 			case Heuristic.Euclidean:
 				v1 = (uint)(((GetHTarget () - node.position).costMagnitude)*heuristicScale);
-				v2 = hTargetNode != null ? AstarPath.active.euclideanEmbedding.GetHeuristic ( node.NodeIndex, hTargetNode.NodeIndex ) : 0;
+				v2 = hTargetNode != null ? AstarPath.newActive.euclideanEmbedding.GetHeuristic ( node.NodeIndex, hTargetNode.NodeIndex ) : 0;
 				return System.Math.Max (v1,v2);
 			case Heuristic.Manhattan:
 				Int3 p2 = node.position;
 				v1 = (uint)((System.Math.Abs (hTarget.x-p2.x) + System.Math.Abs (hTarget.y-p2.y) + System.Math.Abs (hTarget.z-p2.z))*heuristicScale);
-				v2 = hTargetNode != null ? AstarPath.active.euclideanEmbedding.GetHeuristic ( node.NodeIndex, hTargetNode.NodeIndex ) : 0;
+				v2 = hTargetNode != null ? AstarPath.newActive.euclideanEmbedding.GetHeuristic ( node.NodeIndex, hTargetNode.NodeIndex ) : 0;
 				return System.Math.Max (v1,v2);
 			case Heuristic.DiagonalManhattan:
 				Int3 p = GetHTarget () - node.position;
@@ -284,7 +284,7 @@ yield return StartCoroutine (p.WaitForPath ());
 				int diag = System.Math.Min (p.x,p.z);
 				int diag2 = System.Math.Max (p.x,p.z);
 				v1 = (uint)((((14*diag)/10) + (diag2-diag) + p.y) * heuristicScale);
-				v2 = hTargetNode != null ? AstarPath.active.euclideanEmbedding.GetHeuristic ( node.NodeIndex, hTargetNode.NodeIndex ) : 0;
+				v2 = hTargetNode != null ? AstarPath.newActive.euclideanEmbedding.GetHeuristic ( node.NodeIndex, hTargetNode.NodeIndex ) : 0;
 				return System.Math.Max (v1,v2);
 			}
 			return 0U;
@@ -383,11 +383,11 @@ yield return StartCoroutine (p.WaitForPath ());
 #endif
 		public void LogError (string msg) {
 			// Optimize for release builds
-			if (!(!AstarPath.isEditor && AstarPath.active.logPathResults == PathLog.None)) {
+			if (!(!AstarPath.isEditor && AstarPath.newActive.logPathResults == PathLog.None)) {
 				_errorLog += msg;
 			}
 			
-			if (AstarPath.active.logPathResults != PathLog.None && AstarPath.active.logPathResults != PathLog.InGame) {
+			if (AstarPath.newActive.logPathResults != PathLog.None && AstarPath.newActive.logPathResults != PathLog.InGame) {
 				Debug.LogWarning (msg);
 			}
 		}
@@ -410,7 +410,7 @@ yield return StartCoroutine (p.WaitForPath ());
 		  */
 		public void Log (string msg) {
 			// Optimize for release builds
-			if (!(!AstarPath.isEditor && AstarPath.active.logPathResults == PathLog.None)) {
+			if (!(!AstarPath.isEditor && AstarPath.newActive.logPathResults == PathLog.None)) {
 				_errorLog += msg;
 			}
 		}
@@ -465,7 +465,7 @@ yield return StartCoroutine (p.WaitForPath ());
 			pathTraceInfo += System.Environment.StackTrace;
 #endif
 				
-			if (System.Object.ReferenceEquals (AstarPath.active, null))
+			if (System.Object.ReferenceEquals (AstarPath.newActive, null))
 				throw new System.NullReferenceException ("No AstarPath object found in the scene. " +
 					"Make sure there is one or do not create paths in Awake");
 			
@@ -499,15 +499,15 @@ yield return StartCoroutine (p.WaitForPath ());
 			
 			//heuristic = (Heuristic)0;
 			//heuristicScale = 1F;
-			heuristic = AstarPath.active.heuristic;
-			heuristicScale = AstarPath.active.heuristicScale;
+			heuristic = AstarPath.newActive.heuristic;
+			heuristicScale = AstarPath.newActive.heuristicScale;
 			
 			pathID = 0;
 			enabledTags = -1;
 			tagPenalties = null;
 
 			callTime = System.DateTime.UtcNow;
-			pathID = AstarPath.active.GetNextPathID ();
+			pathID = AstarPath.newActive.GetNextPathID ();
 			
 			hTarget = Int3.zero;
 			hTargetNode = null;
diff --git a/Assets/AstarPathfindingProject/Core/Serialization/JsonSerializer.cs b/Assets/AstarPathfindingProject/Core/Serialization/JsonSerializer.cs
index 97c98d3..02f94b1 100644
--- a/Assets/AstarPathfindingProject/Core/Serialization/JsonSerializer.cs
+++ b/Assets/AstarPathfindingProject/Core/Serialization/JsonSerializer.cs
@@ -89,7 +89,7 @@ namespace Pathfinding.Serialization
 			}
 			
 			int inst = ob.GetInstanceID();
-			string name = ob.name;
+			string name = ob.newName;
 			string type = ob.GetType().AssemblyQualifiedName;
 			string guid = "";
 			
@@ -105,7 +105,7 @@ namespace Pathfinding.Serialization
 				UnityReferenceHelper helper = go.GetComponent<UnityReferenceHelper>();
 				
 				if (helper == null) {
-					Debug.Log ("Adding UnityReferenceHelper to Unity Reference '"+ob.name+"'");
+					Debug.Log ("Adding UnityReferenceHelper to Unity Reference '"+ob.newName+"'");
 					helper = go.AddComponent<UnityReferenceHelper>();
 				}
 				
@@ -161,7 +161,7 @@ namespace Pathfinding.Serialization
 			UnityEngine.Object[] objs = Resources.LoadAll (name,type);
 			
 			for (int i=0;i<objs.Length;i++) {
-				if (objs[i].name == name || objs.Length == 1) {
+				if (objs[i].newName == name || objs.Length == 1) {
 					return objs[i];
 				}
 			}
diff --git a/Assets/AstarPathfindingProject/Editor/AstarPathEditor.cs b/Assets/AstarPathfindingProject/Editor/AstarPathEditor.cs
index 6d27ed9..a25692b 100644
--- a/Assets/AstarPathfindingProject/Editor/AstarPathEditor.cs
+++ b/Assets/AstarPathfindingProject/Editor/AstarPathEditor.cs
@@ -640,7 +640,7 @@ public class AstarPathEditor : Editor {
 		if (System.DateTime.Compare (lastUpdateCheck.AddDays (updateCheckRate),System.DateTime.UtcNow) < 0) {
 			Debug.Log ("Checking For Updates... " + System.DateTime.UtcNow.ToString (System.Globalization.CultureInfo.InvariantCulture)+"\nA* Pathfinding Project");
 
-			bool use = AstarPath.active != null || GameObject.FindObjectOfType(typeof(AstarPath)) != null;
+			bool use = AstarPath.newActive != null || GameObject.FindObjectOfType(typeof(AstarPath)) != null;
 			bool mecanim = false;
 #if !UNITY_BEFORE_4
 			mecanim = GameObject.FindObjectOfType(typeof(Animator)) != null;
@@ -1306,7 +1306,7 @@ public class AstarPathEditor : Editor {
 		
 		script = target as AstarPath;
 		
-		AstarPath.active = script;
+		AstarPath.newActive = script;
 		
 		if (!stylesLoaded) {
 			LoadStyles ();
@@ -1977,7 +1977,7 @@ public class AstarPathEditor : Editor {
 	}
 	
 	public static void EditTags () {
-		AstarPath a = AstarPath.active;
+		AstarPath a = AstarPath.newActive;
 		if (a == null) a = GameObject.FindObjectOfType (typeof(AstarPath)) as AstarPath;
 		if (a != null) {
 			editTags = true;
@@ -2477,7 +2477,7 @@ public class AstarPathEditor : Editor {
 	public byte[] SerializeGraphs (Pathfinding.Serialization.SerializeSettings settings, out uint checksum) {
 		byte[] bytes = null;
 		uint ch = 0;
-		AstarPath.active.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
+		AstarPath.newActive.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
 			Pathfinding.Serialization.AstarSerializer sr = new Pathfinding.Serialization.AstarSerializer(script.astarData, settings);
 			sr.OpenSerialize();
 			script.astarData.SerializeGraphsPart (sr);
@@ -2491,7 +2491,7 @@ public class AstarPathEditor : Editor {
 		}));
 		
 		//Make sure the above work item is run directly
-		AstarPath.active.FlushWorkItems();
+		AstarPath.newActive.FlushWorkItems();
 		checksum = ch;
 		return bytes;
 		
@@ -2511,7 +2511,7 @@ public class AstarPathEditor : Editor {
 	
 	public void DeserializeGraphs (byte[] bytes) {
 		
-		AstarPath.active.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
+		AstarPath.newActive.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
 			Pathfinding.Serialization.AstarSerializer sr = new Pathfinding.Serialization.AstarSerializer(script.astarData);
 			if (sr.OpenDeserialize(bytes)) {
 				script.astarData.DeserializeGraphsPart (sr);
@@ -2530,22 +2530,22 @@ public class AstarPathEditor : Editor {
 		}));
 		
 		//Make sure the above work item is run directly
-		AstarPath.active.FlushWorkItems();
+		AstarPath.newActive.FlushWorkItems();
 	}
 	
 	[UnityEditor.MenuItem ("Edit/Pathfinding/Scan All Graphs %&s")]
 	public static void MenuScan () {
 		
-		if (AstarPath.active == null) {
-			AstarPath.active = FindObjectOfType(typeof(AstarPath)) as AstarPath;
-			if (AstarPath.active == null) {
+		if (AstarPath.newActive == null) {
+			AstarPath.newActive = FindObjectOfType(typeof(AstarPath)) as AstarPath;
+			if (AstarPath.newActive == null) {
 				return;
 			}
 		}
 		
-		if (!Application.isPlaying && (AstarPath.active.astarData.graphs == null || AstarPath.active.astarData.graphTypes == null)) {
+		if (!Application.isPlaying && (AstarPath.newActive.astarData.graphs == null || AstarPath.newActive.astarData.graphTypes == null)) {
 			UnityEditor.EditorUtility.DisplayProgressBar ("Scanning","Deserializing",0);
-			AstarPath.active.astarData.DeserializeGraphs ();
+			AstarPath.newActive.astarData.DeserializeGraphs ();
 		}
 		
 		UnityEditor.EditorUtility.DisplayProgressBar ("Scanning","Scanning...",0);
@@ -2554,7 +2554,7 @@ public class AstarPathEditor : Editor {
 			OnScanStatus info = delegate (Progress p) {
 				UnityEditor.EditorUtility.DisplayProgressBar ("Scanning",p.description,p.progress);
 			};
-			AstarPath.active.ScanLoop (info);
+			AstarPath.newActive.ScanLoop (info);
 			
 		} catch (System.Exception e) {
 			Debug.LogError ("There was an error generating the graphs:\n"+e.ToString ()+"\n\nIf you think this is a bug, please contact me on arongranberg.com (post a comment)\n");
diff --git a/Assets/AstarPathfindingProject/Editor/GraphEditors/GraphEditor.cs b/Assets/AstarPathfindingProject/Editor/GraphEditors/GraphEditor.cs
index 8be5528..6e8a679 100644
--- a/Assets/AstarPathfindingProject/Editor/GraphEditors/GraphEditor.cs
+++ b/Assets/AstarPathfindingProject/Editor/GraphEditors/GraphEditor.cs
@@ -15,8 +15,8 @@ namespace Pathfinding {
 		  * Will only scan graphs if not playing and time to scan last graph was less than some constant (to avoid lag with large graphs) */
 		public bool AutoScan () {
 			
-			if (!Application.isPlaying && AstarPath.active != null && AstarPath.active.lastScanTime < 0.11F) {
-				AstarPath.active.Scan ();
+			if (!Application.isPlaying && AstarPath.newActive != null && AstarPath.newActive.lastScanTime < 0.11F) {
+				AstarPath.newActive.Scan ();
 				return true;
 			}
 			return false;
@@ -80,7 +80,7 @@ namespace Pathfinding {
 							}
 							string ext = System.IO.Path.GetExtension(path);
 							
-							string error = AssetDatabase.MoveAsset	(path,"Assets/Resources/"+obj.name+ext);
+							string error = AssetDatabase.MoveAsset	(path,"Assets/Resources/"+obj.newName+ext);
 							
 							if (error == "") {
 								//Debug.Log ("Successful move");
@@ -91,9 +91,9 @@ namespace Pathfinding {
 						}
 					}
 					
-					if (!AssetDatabase.IsMainAsset (obj) && obj.name != AssetDatabase.LoadMainAssetAtPath (path).name) {
+					if (!AssetDatabase.IsMainAsset (obj) && obj.newName != AssetDatabase.LoadMainAssetAtPath (path).newName) {
 						if (FixLabel ("Due to technical reasons, the main asset must\nhave the same name as the referenced asset")) {
-							string error = AssetDatabase.RenameAsset (path,obj.name);
+							string error = AssetDatabase.RenameAsset (path,obj.newName);
 							if (error == "") {
 								//Debug.Log ("Successful");
 							} else {
diff --git a/Assets/AstarPathfindingProject/Editor/GraphEditors/GridGeneratorEditor.cs b/Assets/AstarPathfindingProject/Editor/GraphEditors/GridGeneratorEditor.cs
index 007f772..372706e 100644
--- a/Assets/AstarPathfindingProject/Editor/GraphEditors/GridGeneratorEditor.cs
+++ b/Assets/AstarPathfindingProject/Editor/GraphEditors/GridGeneratorEditor.cs
@@ -395,7 +395,7 @@ namespace Pathfinding {
 			//GridGraph graph = target as GridGraph;
 			
 			if (graph.nodes == null || graph.nodes.Length != graph.width * graph.depth) {
-				AstarPath.active.Scan ();
+				AstarPath.newActive.Scan ();
 			}
 			
 			if (graph.nodes.Length != graph.width * graph.depth) {
@@ -466,7 +466,7 @@ namespace Pathfinding {
 						}
 						string ext = System.IO.Path.GetExtension(path);
 						
-						string error = AssetDatabase.MoveAsset	(path,"Assets/Resources/"+obj.name+ext);
+						string error = AssetDatabase.MoveAsset	(path,"Assets/Resources/"+obj.newName+ext);
 						
 						if (error == "") {
 							//Debug.Log ("Successful move");
diff --git a/Assets/AstarPathfindingProject/ExampleScenes/Example12_Procedural/ProceduralGridMover.cs b/Assets/AstarPathfindingProject/ExampleScenes/Example12_Procedural/ProceduralGridMover.cs
index 126ed0a..5c6ba2d 100644
--- a/Assets/AstarPathfindingProject/ExampleScenes/Example12_Procedural/ProceduralGridMover.cs
+++ b/Assets/AstarPathfindingProject/ExampleScenes/Example12_Procedural/ProceduralGridMover.cs
@@ -27,9 +27,9 @@ public class ProceduralGridMover : MonoBehaviour {
 	GridNode[] tmp;
 
 	public void Start () {
-		if ( AstarPath.active == null ) throw new System.Exception ("There is no AstarPath object in the scene");
+		if ( AstarPath.newActive == null ) throw new System.Exception ("There is no AstarPath object in the scene");
 
-		graph = AstarPath.active.astarData.gridGraph;
+		graph = AstarPath.newActive.astarData.gridGraph;
 
 		if ( graph == null ) throw new System.Exception ("The AstarPath object has no GridGraph");
 		UpdateGraph ();
@@ -55,7 +55,7 @@ public class ProceduralGridMover : MonoBehaviour {
 		// (hence the IEnumerator coroutine)
 		// to avoid too large FPS drops
 		IEnumerator ie = UpdateGraphCoroutine ();
-		AstarPath.active.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
+		AstarPath.newActive.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
 			if ( force ) while ( ie.MoveNext () ) {}
 			return !ie.MoveNext ();
 		}));
@@ -225,7 +225,7 @@ public class ProceduralGridMover : MonoBehaviour {
 			// Make sure the areas for the graph
 			// have been recalculated
 			// not doing this can cause pathfinding to fail
-			AstarPath.active.QueueWorkItemFloodFill ();
+			AstarPath.newActive.QueueWorkItemFloodFill ();
 		}
 	}
 }
diff --git a/Assets/AstarPathfindingProject/ExampleScenes/Example12_Procedural/ProceduralWorld.cs b/Assets/AstarPathfindingProject/ExampleScenes/Example12_Procedural/ProceduralWorld.cs
index 4dde9ce..f759356 100644
--- a/Assets/AstarPathfindingProject/ExampleScenes/Example12_Procedural/ProceduralWorld.cs
+++ b/Assets/AstarPathfindingProject/ExampleScenes/Example12_Procedural/ProceduralWorld.cs
@@ -67,7 +67,7 @@ public class ProceduralWorld : MonoBehaviour {
 		// Calculate the closest tiles
 		// and then recalculate the graph
 		Update ();
-		AstarPath.active.Scan ();
+		AstarPath.newActive.Scan ();
 
 		StartCoroutine (GenerateTiles ());
 	}
diff --git a/Assets/AstarPathfindingProject/ExampleScenes/Example8_PathTypes/PathTypesDemo.cs b/Assets/AstarPathfindingProject/ExampleScenes/Example8_PathTypes/PathTypesDemo.cs
index b41570c..6c62b38 100644
--- a/Assets/AstarPathfindingProject/ExampleScenes/Example8_PathTypes/PathTypesDemo.cs
+++ b/Assets/AstarPathfindingProject/ExampleScenes/Example8_PathTypes/PathTypesDemo.cs
@@ -355,7 +355,7 @@ public class PathTypesDemo : MonoBehaviour {
 				for (int i=0;i<agents.Length;i++) pts[i] -= avg;
 				//List<Vector3> pts = Pathfinding.PathUtilities.GetSpiralPoints (agents.Length, 0.2f);
 				
-				Pathfinding.PathUtilities.GetPointsAroundPoint (end.position, AstarPath.active.graphs[0] as IRaycastableGraph, pts, 0, 0.2f);
+				Pathfinding.PathUtilities.GetPointsAroundPoint (end.position, AstarPath.newActive.graphs[0] as IRaycastableGraph, pts, 0, 0.2f);
 				//for (int i=0;i<pts.Count;i++) pts[i] += end.position;
 				for (int i=0;i<agents.Length;i++) {
 					if (agents[i] == null) continue;
diff --git a/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/DoorController.cs b/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/DoorController.cs
index ad8bd3c..e7b7516 100644
--- a/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/DoorController.cs
+++ b/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/DoorController.cs
@@ -43,7 +43,7 @@ public class DoorController : MonoBehaviour {
 			guo.updatePhysics = false;
 	#endif
 			
-			AstarPath.active.UpdateGraphs (guo);
+			AstarPath.newActive.UpdateGraphs (guo);
 		}
 		
 		if (open) {
diff --git a/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/DynamicGridObstacle.cs b/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/DynamicGridObstacle.cs
index a39182a..d886366 100644
--- a/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/DynamicGridObstacle.cs
+++ b/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/DynamicGridObstacle.cs
@@ -33,7 +33,7 @@ public class DynamicGridObstacle : MonoBehaviour {
 	/** Coroutine which checks for changes in the collider's bounding box */
 	IEnumerator UpdateGraphs () {
 		
-		if (col == null || AstarPath.active == null) {
+		if (col == null || AstarPath.newActive == null) {
 			Debug.LogWarning ("No collider is attached to the GameObject. Canceling check");
 			yield break;
 		}
@@ -75,9 +75,9 @@ public class DynamicGridObstacle : MonoBehaviour {
 	/** Revert graphs when destroyed.
 	 * When the DynamicObstacle is destroyed, a last graph update should be done to revert nodes to their original state */
 	public void OnDestroy () {
-		if (AstarPath.active != null) {
+		if (AstarPath.newActive != null) {
 			GraphUpdateObject guo = new GraphUpdateObject (prevBounds);
-			AstarPath.active.UpdateGraphs (guo);
+			AstarPath.newActive.UpdateGraphs (guo);
 		}
 	}
 	
@@ -94,11 +94,11 @@ public class DynamicGridObstacle : MonoBehaviour {
 		// or to update them separately, the smallest volume is usually the fastest
 		if (BoundsVolume (merged) < BoundsVolume (newBounds)+BoundsVolume(prevBounds)) {
 			// Send an update request to update the nodes inside the 'merged' volume
-			AstarPath.active.UpdateGraphs (merged);
+			AstarPath.newActive.UpdateGraphs (merged);
 		} else {
 			// Send two update request to update the nodes inside the 'prevBounds' and 'newBounds' volumes
-			AstarPath.active.UpdateGraphs (prevBounds);
-			AstarPath.active.UpdateGraphs (newBounds);
+			AstarPath.newActive.UpdateGraphs (prevBounds);
+			AstarPath.newActive.UpdateGraphs (newBounds);
 		}
 		
 #if ASTARDEBUG
diff --git a/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/NavmeshClamp.cs b/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/NavmeshClamp.cs
index 9cfe24a..30e9d99 100644
--- a/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/NavmeshClamp.cs
+++ b/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/NavmeshClamp.cs
@@ -21,7 +21,7 @@ namespace Pathfinding {
 		void LateUpdate () {
 			
 			if (prevNode == null) {
-				NNInfo nninfo = AstarPath.active.GetNearest (transform.position);
+				NNInfo nninfo = AstarPath.newActive.GetNearest (transform.position);
 				prevNode = nninfo.node;
 				prevPos = transform.position;
 				
diff --git a/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/ObjectPlacer.cs b/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/ObjectPlacer.cs
index 679016f..4fe92cb 100644
--- a/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/ObjectPlacer.cs
+++ b/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/ObjectPlacer.cs
@@ -35,10 +35,10 @@ public class ObjectPlacer : MonoBehaviour {
 				Bounds b = obj.collider.bounds;
 				//Pathfinding.Console.Write ("// Placing Object\n");
 				GraphUpdateObject guo = new GraphUpdateObject(b);
-				AstarPath.active.UpdateGraphs (guo);
+				AstarPath.newActive.UpdateGraphs (guo);
 				if (direct) {
 					//Pathfinding.Console.Write ("// Flushing\n");
-					AstarPath.active.FlushGraphUpdates();
+					AstarPath.newActive.FlushGraphUpdates();
 				}
 			}
 		}
@@ -48,7 +48,7 @@ public class ObjectPlacer : MonoBehaviour {
 		Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);
 		RaycastHit hit;
 		if ( Physics.Raycast (ray, out hit, Mathf.Infinity)) {
-			if (hit.collider.isTrigger || hit.transform.gameObject.name == "Ground") return;
+			if (hit.collider.isTrigger || hit.transform.gameObject.newName == "Ground") return;
 			
 			Bounds b = hit.collider.bounds;
 			Destroy (hit.collider);
@@ -57,10 +57,10 @@ public class ObjectPlacer : MonoBehaviour {
 			//Pathfinding.Console.Write ("// Placing Object\n");
 			if (issueGUOs) {
 				GraphUpdateObject guo = new GraphUpdateObject(b);
-				AstarPath.active.UpdateGraphs (guo,0.0f);
+				AstarPath.newActive.UpdateGraphs (guo,0.0f);
 				if (direct) {
 					//Pathfinding.Console.Write ("// Flushing\n");
-					AstarPath.active.FlushGraphUpdates();
+					AstarPath.newActive.FlushGraphUpdates();
 				}
 			}
 		}
diff --git a/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/RecastTileUpdateHandler.cs b/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/RecastTileUpdateHandler.cs
index 7a5b1e2..f363fda 100644
--- a/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/RecastTileUpdateHandler.cs
+++ b/Assets/AstarPathfindingProject/ExampleScenes/ExampleScripts/RecastTileUpdateHandler.cs
@@ -70,8 +70,8 @@ public class RecastTileUpdateHandler : MonoBehaviour {
 
 		if (graph == null) {
 			// If no graph has been set, use the first graph available
-			if (AstarPath.active != null) {
-				SetGraph (AstarPath.active.astarData.recastGraph);
+			if (AstarPath.newActive != null) {
+				SetGraph (AstarPath.newActive.astarData.recastGraph);
 			}
 			
 			if (graph == null) {
@@ -147,7 +147,7 @@ public class RecastTileUpdateHandler : MonoBehaviour {
 					var guo = new GraphUpdateObject (bounds);
 					guo.nnConstraint.graphMask = 1 << (int)graph.graphIndex;
 
-					AstarPath.active.UpdateGraphs (guo);
+					AstarPath.newActive.UpdateGraphs (guo);
 				}
 			}
 		}
diff --git a/Assets/AstarPathfindingProject/Generators/Base.cs b/Assets/AstarPathfindingProject/Generators/Base.cs
index 763d916..4989672 100644
--- a/Assets/AstarPathfindingProject/Generators/Base.cs
+++ b/Assets/AstarPathfindingProject/Generators/Base.cs
@@ -171,7 +171,7 @@ namespace Pathfinding {
 		public virtual NNInfo GetNearest (Vector3 position, NNConstraint constraint, GraphNode hint) {
 			//Debug.LogError ("This function (GetNearest) is not implemented in the navigation graph generator : Type "+this.GetType ().Name);
 			
-			float maxDistSqr = constraint.constrainDistance ? AstarPath.active.maxNearestNodeDistanceSqr : float.PositiveInfinity;
+			float maxDistSqr = constraint.constrainDistance ? AstarPath.newActive.maxNearestNodeDistanceSqr : float.PositiveInfinity;
 			
 			float minDist = float.PositiveInfinity;
 			GraphNode minNode = null;
@@ -265,7 +265,7 @@ namespace Pathfinding {
 		public void ScanGraph () {
 			
 			if (AstarPath.OnPreScan != null) {
-				AstarPath.OnPreScan (AstarPath.active);
+				AstarPath.OnPreScan (AstarPath.newActive);
 			}
 			
 			if (AstarPath.OnGraphPreScan != null) {
@@ -279,7 +279,7 @@ namespace Pathfinding {
 			}
 			
 			if (AstarPath.OnPostScan != null) {
-				AstarPath.OnPostScan (AstarPath.active);
+				AstarPath.OnPostScan (AstarPath.newActive);
 			}
 		}
 
@@ -310,13 +310,13 @@ namespace Pathfinding {
 			
 			if (node == null) return AstarColor.NodeConnection;
 			
-			switch (AstarPath.active.debugMode) {
+			switch (AstarPath.newActive.debugMode) {
 				case GraphDebugMode.Areas:
 					c = AstarColor.GetAreaColor (node.Area);
 					colSet = true;
 					break;
 				case GraphDebugMode.Penalty:
-					c = Color.Lerp (AstarColor.ConnectionLowLerp,AstarColor.ConnectionHighLerp, ((float)node.Penalty-AstarPath.active.debugFloor) / (AstarPath.active.debugRoof-AstarPath.active.debugFloor));
+					c = Color.Lerp (AstarColor.ConnectionLowLerp,AstarColor.ConnectionHighLerp, ((float)node.Penalty-AstarPath.newActive.debugFloor) / (AstarPath.newActive.debugRoof-AstarPath.newActive.debugFloor));
 					colSet = true;
 					break;
 				case GraphDebugMode.Tags:
@@ -341,16 +341,16 @@ namespace Pathfinding {
 				
 				PathNode nodeR = data.GetPathNode (node);
 				
-				switch (AstarPath.active.debugMode) {
+				switch (AstarPath.newActive.debugMode) {
 					case GraphDebugMode.G:
 						//c = Mathfx.IntToColor (node.g,0.5F);
-						c = Color.Lerp (AstarColor.ConnectionLowLerp,AstarColor.ConnectionHighLerp, ((float)nodeR.G-AstarPath.active.debugFloor) / (AstarPath.active.debugRoof-AstarPath.active.debugFloor));
+						c = Color.Lerp (AstarColor.ConnectionLowLerp,AstarColor.ConnectionHighLerp, ((float)nodeR.G-AstarPath.newActive.debugFloor) / (AstarPath.newActive.debugRoof-AstarPath.newActive.debugFloor));
 						break;
 					case GraphDebugMode.H:
-						c = Color.Lerp (AstarColor.ConnectionLowLerp,AstarColor.ConnectionHighLerp, ((float)nodeR.H-AstarPath.active.debugFloor) / (AstarPath.active.debugRoof-AstarPath.active.debugFloor));
+						c = Color.Lerp (AstarColor.ConnectionLowLerp,AstarColor.ConnectionHighLerp, ((float)nodeR.H-AstarPath.newActive.debugFloor) / (AstarPath.newActive.debugRoof-AstarPath.newActive.debugFloor));
 						break;
 					case GraphDebugMode.F:
-						c = Color.Lerp (AstarColor.ConnectionLowLerp,AstarColor.ConnectionHighLerp, ((float)nodeR.F-AstarPath.active.debugFloor) / (AstarPath.active.debugRoof-AstarPath.active.debugFloor));
+						c = Color.Lerp (AstarColor.ConnectionLowLerp,AstarColor.ConnectionHighLerp, ((float)nodeR.F-AstarPath.newActive.debugFloor) / (AstarPath.newActive.debugRoof-AstarPath.newActive.debugFloor));
 						break;
 				}
 			}
@@ -436,7 +436,7 @@ namespace Pathfinding {
 				return;
 			}
 			
-			PathHandler data = AstarPath.active.debugPathData;
+			PathHandler data = AstarPath.newActive.debugPathData;
 			
 			GraphNode node = null;
 			
@@ -447,12 +447,12 @@ namespace Pathfinding {
 			GetNodes (delegate (GraphNode _node) {
 				node = _node;
 				
-				Gizmos.color = NodeColor (node, AstarPath.active.debugPathData);
-				if (AstarPath.active.showSearchTree && !InSearchTree(node,AstarPath.active.debugPath)) return true;
+				Gizmos.color = NodeColor (node, AstarPath.newActive.debugPathData);
+				if (AstarPath.newActive.showSearchTree && !InSearchTree(node,AstarPath.newActive.debugPath)) return true;
 				
 				
 				PathNode nodeR = data != null ? data.GetPathNode (node) : null;
-				if (AstarPath.active.showSearchTree && nodeR != null && nodeR.parent != null) {
+				if (AstarPath.newActive.showSearchTree && nodeR != null && nodeR.parent != null) {
 					Gizmos.DrawLine ((Vector3)node.position,(Vector3)nodeR.parent.node.position);
 				} else {
 					node.GetConnections (del);
diff --git a/Assets/AstarPathfindingProject/Generators/GridGenerator.cs b/Assets/AstarPathfindingProject/Generators/GridGenerator.cs
index 7351afe..bbcd7e7 100644
--- a/Assets/AstarPathfindingProject/Generators/GridGenerator.cs
+++ b/Assets/AstarPathfindingProject/Generators/GridGenerator.cs
@@ -84,7 +84,7 @@ AstarPath.active.Scan();
 		}
 		
 		public void RemoveGridGraphFromStatic () {
-			GridNode.SetGridGraph (AstarPath.active.astarData.GetGraphIndex(this),null);
+			GridNode.SetGridGraph (AstarPath.newActive.astarData.GetGraphIndex(this),null);
 		}
 		
 		/** This is placed here so generators inheriting from this one can override it and set it to false.
@@ -619,7 +619,7 @@ AstarPath.active.Scan();
 				else overlap--;
 			}
 			
-			float maxDist = constraint.constrainDistance ? AstarPath.active.maxNearestNodeDistance : float.PositiveInfinity;
+			float maxDist = constraint.constrainDistance ? AstarPath.newActive.maxNearestNodeDistance : float.PositiveInfinity;
 			float maxDistSqr = maxDist*maxDist;
 			
 
@@ -798,7 +798,7 @@ AstarPath.active.Scan();
 			
 			SetUpOffsetsAndCosts ();
 			
-			int graphIndex = AstarPath.active.astarData.GetGraphIndex(this);
+			int graphIndex = AstarPath.newActive.astarData.GetGraphIndex(this);
 			GridNode.SetGridGraph (graphIndex,this);
 
 			nodes = new GridNode[width*depth];
@@ -1262,7 +1262,7 @@ AstarPath.active.Scan();
 				return;
 			}
 
-			PathHandler debugData = AstarPath.active.debugPathData;
+			PathHandler debugData = AstarPath.newActive.debugPathData;
 			
 			GridNode node = null;
 
@@ -1274,10 +1274,10 @@ AstarPath.active.Scan();
 						continue;
 					}
 
-					Gizmos.color = NodeColor (node,AstarPath.active.debugPathData);
+					Gizmos.color = NodeColor (node,AstarPath.newActive.debugPathData);
 
-					if (AstarPath.active.showSearchTree && debugData != null) {
-						if (InSearchTree(node,AstarPath.active.debugPath)) {
+					if (AstarPath.newActive.showSearchTree && debugData != null) {
+						if (InSearchTree(node,AstarPath.newActive.debugPath)) {
 							PathNode nodeR = debugData.GetPathNode (node);
 							if (nodeR != null && nodeR.parent != null) {
 								Gizmos.DrawLine ((Vector3)node.position, (Vector3)nodeR.parent.node.position);
@@ -2046,7 +2046,7 @@ AstarPath.active.Scan();
 				return;
 			}
 			
-			GridNode.SetGridGraph (AstarPath.active.astarData.GetGraphIndex(this),this);
+			GridNode.SetGridGraph (AstarPath.newActive.astarData.GetGraphIndex(this),this);
 			
 			for (int z = 0; z < depth; z ++) {
 				for (int x = 0; x < width; x++) {
diff --git a/Assets/AstarPathfindingProject/Generators/LayerGridGraphGenerator.cs b/Assets/AstarPathfindingProject/Generators/LayerGridGraphGenerator.cs
index d83402f..0197435 100644
--- a/Assets/AstarPathfindingProject/Generators/LayerGridGraphGenerator.cs
+++ b/Assets/AstarPathfindingProject/Generators/LayerGridGraphGenerator.cs
@@ -1104,7 +1104,7 @@ namespace Pathfinding {
 			
 			//int counter = 0;
 			
-			float maxDist = constraint.constrainDistance ? AstarPath.active.maxNearestNodeDistance : float.PositiveInfinity;
+			float maxDist = constraint.constrainDistance ? AstarPath.newActive.maxNearestNodeDistance : float.PositiveInfinity;
 			float maxDistSqr = maxDist*maxDist;
 			
 			//for (int w = 1; w < getNearestForceLimit;w++) {
@@ -1468,7 +1468,7 @@ namespace Pathfinding {
 				return;
 			}
 			
-			PathHandler debugData = AstarPath.active.debugPathData;
+			PathHandler debugData = AstarPath.newActive.debugPathData;
 			
 			for (int n=0;n<nodes.Length;n++) {
 				
@@ -1478,10 +1478,10 @@ namespace Pathfinding {
 				
 				//int index = node.GetIndex ();
 				
-				Gizmos.color = NodeColor (node,AstarPath.active.debugPathData);
+				Gizmos.color = NodeColor (node,AstarPath.newActive.debugPathData);
 				
-				if (AstarPath.active.showSearchTree && AstarPath.active.debugPathData != null) {
-					if (InSearchTree(node,AstarPath.active.debugPath)) {
+				if (AstarPath.newActive.showSearchTree && AstarPath.newActive.debugPathData != null) {
+					if (InSearchTree(node,AstarPath.newActive.debugPath)) {
 						PathNode nodeR = debugData.GetPathNode (node);
 						if (nodeR != null && nodeR.parent != null) {
 							Gizmos.DrawLine ((Vector3)node.position, (Vector3)nodeR.parent.node.position);
@@ -1564,7 +1564,7 @@ namespace Pathfinding {
 			
 			if (nodes == null || nodes.Length == 0) return;
 
-			LevelGridNode.SetGridGraph (AstarPath.active.astarData.GetGraphIndex(this),this);
+			LevelGridNode.SetGridGraph (AstarPath.newActive.astarData.GetGraphIndex(this),this);
 			
 			for (int z = 0; z < depth; z ++) {
 				for (int x = 0; x < width; x++) {
diff --git a/Assets/AstarPathfindingProject/Generators/NavMeshGenerator.cs b/Assets/AstarPathfindingProject/Generators/NavMeshGenerator.cs
index 0e44978..f7867ee 100644
--- a/Assets/AstarPathfindingProject/Generators/NavMeshGenerator.cs
+++ b/Assets/AstarPathfindingProject/Generators/NavMeshGenerator.cs
@@ -203,7 +203,7 @@ and have a low memory footprint because of their smaller size to describe the sa
 				for (int i=1;i<=8;i++) {
 					query = graph.bbTree.QueryCircle (position, i*i*w, constraint);
 					
-					if (query.node != null || (i-1)*(i-1)*w > AstarPath.active.maxNearestNodeDistance*2) { // *2 for a margin
+					if (query.node != null || (i-1)*(i-1)*w > AstarPath.newActive.maxNearestNodeDistance*2) { // *2 for a margin
 						break;
 					}
 				}
@@ -214,7 +214,7 @@ and have a low memory footprint because of their smaller size to describe the sa
 			}
 			
 			if (query.constrainedNode != null) {
-				if (constraint.constrainDistance && ((Vector3)query.constrainedNode.position - position).sqrMagnitude > AstarPath.active.maxNearestNodeDistanceSqr) {
+				if (constraint.constrainDistance && ((Vector3)query.constrainedNode.position - position).sqrMagnitude > AstarPath.newActive.maxNearestNodeDistanceSqr) {
 					query.constrainedNode = null;
 				} else {
 					query.constClampedPosition = ClosestPointOnNode (query.constrainedNode as TriangleMeshNode, vertices, position);
@@ -261,7 +261,7 @@ and have a low memory footprint because of their smaller size to describe the sa
 			float minConstDist = -1;
 			GraphNode minConstNode = null;
 			
-			float maxDistSqr = constraint.constrainDistance ? AstarPath.active.maxNearestNodeDistanceSqr : float.PositiveInfinity;
+			float maxDistSqr = constraint.constrainDistance ? AstarPath.newActive.maxNearestNodeDistanceSqr : float.PositiveInfinity;
 			
 			GraphNodeDelegateCancelable del = delegate (GraphNode _node) {
 				TriangleMeshNode node = _node as TriangleMeshNode;
@@ -1069,17 +1069,17 @@ and have a low memory footprint because of their smaller size to describe the sa
 				RelocateNodes (preMatrix, matrix);
 			}
 			
-			PathHandler debugData = AstarPath.active.debugPathData;
+			PathHandler debugData = AstarPath.newActive.debugPathData;
 			for (int i=0;i<nodes.Length;i++) {
 				
 				
 				TriangleMeshNode node = (TriangleMeshNode)nodes[i];
 				
-				Gizmos.color = NodeColor (node,AstarPath.active.debugPathData);
+				Gizmos.color = NodeColor (node,AstarPath.newActive.debugPathData);
 				
 				if (node.Walkable ) {
 					
-					if (AstarPath.active.showSearchTree && debugData != null && debugData.GetPathNode(node).parent != null) {
+					if (AstarPath.newActive.showSearchTree && debugData != null && debugData.GetPathNode(node).parent != null) {
 						Gizmos.DrawLine ((Vector3)node.position,(Vector3)debugData.GetPathNode(node).parent.node.position);
 					} else {
 						for (int q=0;q<node.connections.Length;q++) {
diff --git a/Assets/AstarPathfindingProject/Generators/PointGenerator.cs b/Assets/AstarPathfindingProject/Generators/PointGenerator.cs
index e387efc..8acad7d 100644
--- a/Assets/AstarPathfindingProject/Generators/PointGenerator.cs
+++ b/Assets/AstarPathfindingProject/Generators/PointGenerator.cs
@@ -199,7 +199,7 @@ namespace Pathfinding {
 			
 			if (nodes == null) return new NNInfo();
 			
-			float maxDistSqr = constraint.constrainDistance ? AstarPath.active.maxNearestNodeDistanceSqr : float.PositiveInfinity;
+			float maxDistSqr = constraint.constrainDistance ? AstarPath.newActive.maxNearestNodeDistanceSqr : float.PositiveInfinity;
 			
 			float minDist = float.PositiveInfinity;
 			GraphNode minNode = null;
diff --git a/Assets/AstarPathfindingProject/Generators/RecastGenerator.cs b/Assets/AstarPathfindingProject/Generators/RecastGenerator.cs
index e6abb96..656e5f5 100644
--- a/Assets/AstarPathfindingProject/Generators/RecastGenerator.cs
+++ b/Assets/AstarPathfindingProject/Generators/RecastGenerator.cs
@@ -593,7 +593,7 @@ But this time, edit the setting named "Forward" to "Z forward" (not -Z as it is
 					Collider coll = buffer2[i].GetCollider();
 
 					if (coll == null) {
-						Debug.LogError ("RecastMeshObject ("+buffer2[i].gameObject.name +") didn't have a collider or MeshFilter attached");
+						Debug.LogError ("RecastMeshObject ("+buffer2[i].gameObject.newName +") didn't have a collider or MeshFilter attached");
 						continue;
 					}
 
@@ -893,7 +893,7 @@ But this time, edit the setting named "Forward" to "Z forward" (not -Z as it is
 			
 			
 			AstarProfiler.StartProfile ("ConnectTiles");
-			uint graphIndex = (uint)AstarPath.active.astarData.GetGraphIndex (this);
+			uint graphIndex = (uint)AstarPath.newActive.astarData.GetGraphIndex (this);
 			
 			for (int x=r.xmin;x<=r.xmax;x++) {
 				for (int z=r.ymin;z<=r.ymax;z++) {
@@ -1172,7 +1172,7 @@ But this time, edit the setting named "Forward" to "Z forward" (not -Z as it is
 			AstarProfiler.StartProfile ("Base Scan");
 			//AstarProfiler.InitializeFastProfile (new string[] {"Rasterize", "Rasterize Inner 1", "Rasterize Inner 2", "Rasterize Inner 3"});
 			
-			TriangleMeshNode.SetNavmeshHolder (AstarPath.active.astarData.GetGraphIndex (this), this);
+			TriangleMeshNode.SetNavmeshHolder (AstarPath.newActive.astarData.GetGraphIndex (this), this);
 			
 			
 			ScanTiledNavmesh (statusCallback);
@@ -1286,7 +1286,7 @@ But this time, edit the setting named "Forward" to "Z forward" (not -Z as it is
 			if (statusCallback != null) statusCallback (new Progress (0.9f, "Connecting tiles"));
 			
 			//Assign graph index to nodes
-			uint graphIndex = (uint)AstarPath.active.astarData.GetGraphIndex (this);
+			uint graphIndex = (uint)AstarPath.newActive.astarData.GetGraphIndex (this);
 			
 			GraphNodeDelegateCancelable del = delegate (GraphNode n) {
 				n.GraphIndex = graphIndex;
@@ -1533,7 +1533,7 @@ But this time, edit the setting named "Forward" to "Z forward" (not -Z as it is
 			//The tile is not added to any graphs yet, but to get the position querys from the nodes
 			//to work correctly (not throw exceptions because the tile is not calculated) we fake a new graph
 			//and direct the position queries directly to the tile
-			int graphIndex = AstarPath.active.astarData.graphs.Length;
+			int graphIndex = AstarPath.newActive.astarData.graphs.Length;
 			
 			TriangleMeshNode.SetNavmeshHolder (graphIndex, tile);
 			
@@ -1896,7 +1896,7 @@ But this time, edit the setting named "Forward" to "Z forward" (not -Z as it is
 			//The tile is not added to any graphs yet, but to get the position querys from the nodes
 			//to work correctly (not throw exceptions because the tile is not calculated) we fake a new graph
 			//and direct the position queries directly to the tile
-			int graphIndex = AstarPath.active.astarData.graphs.Length;
+			int graphIndex = AstarPath.newActive.astarData.graphs.Length;
 			
 			TriangleMeshNode.SetNavmeshHolder (graphIndex, tile);
 			
@@ -1956,7 +1956,7 @@ But this time, edit the setting named "Forward" to "Z forward" (not -Z as it is
 			
 			//Real graph index
 			//TODO, could this step be changed for this function, is a fake index required?
-			graphIndex = AstarPath.active.astarData.GetGraphIndex (this);
+			graphIndex = AstarPath.newActive.astarData.GetGraphIndex (this);
 			
 			for (int i=0;i<nodes.Length;i++) nodes[i].GraphIndex = (uint)graphIndex;			
 			
@@ -2567,7 +2567,7 @@ But this time, edit the setting named "Forward" to "Z forward" (not -Z as it is
 			Gizmos.DrawWireCube (forcedBounds.center,forcedBounds.size);
 			//base.OnDrawGizmos (drawNodes);
 
-			PathHandler debugData = AstarPath.active.debugPathData;
+			PathHandler debugData = AstarPath.newActive.debugPathData;
 			
 			GraphNodeDelegateCancelable del = delegate (GraphNode _node) {
 				
@@ -2576,8 +2576,8 @@ But this time, edit the setting named "Forward" to "Z forward" (not -Z as it is
 				TriangleMeshNode node = _node as TriangleMeshNode;
 				
 				
-				if (AstarPath.active.showSearchTree && debugData != null) {
-					bool v = InSearchTree(node,AstarPath.active.debugPath);
+				if (AstarPath.newActive.showSearchTree && debugData != null) {
+					bool v = InSearchTree(node,AstarPath.newActive.debugPath);
 						//debugData.GetPathNode(node).parent != null && debugData.GetPathNode(node).parent.node != null;
 					if ( v && showNodeConnections ) {
 						//Gizmos.color = new Color (0,1,0,0.7F);
diff --git a/Assets/AstarPathfindingProject/Generators/Utilities/EuclideanEmbedding.cs b/Assets/AstarPathfindingProject/Generators/Utilities/EuclideanEmbedding.cs
index 03880e7..bb22f58 100644
--- a/Assets/AstarPathfindingProject/Generators/Utilities/EuclideanEmbedding.cs
+++ b/Assets/AstarPathfindingProject/Generators/Utilities/EuclideanEmbedding.cs
@@ -98,7 +98,7 @@ namespace Pathfinding {
 		void GetClosestWalkableNodesToChildrenRecursively ( Transform tr, List<GraphNode> nodes ) {
 			foreach (Transform ch in tr ) {
 
-				NNInfo info = AstarPath.active.GetNearest ( ch.position, NNConstraint.Default );
+				NNInfo info = AstarPath.newActive.GetNearest ( ch.position, NNConstraint.Default );
 				if ( info.node != null && info.node.Walkable ) {
 					nodes.Add ( info.node );
 				}
@@ -117,7 +117,7 @@ namespace Pathfinding {
 			// Reset the random number generator
 			rval = (uint)seed;
 
-			var graphs = AstarPath.active.graphs;
+			var graphs = AstarPath.newActive.graphs;
 
 			// Get a List<GraphNode> from a pool
 			var pivotList = Pathfinding.Util.ListPool<GraphNode>.Claim ();
@@ -242,7 +242,7 @@ namespace Pathfinding {
 					}
 
 
-					var graphs = AstarPath.active.graphs;
+					var graphs = AstarPath.newActive.graphs;
 					// Process graphs in reverse order to raise probability that we encounter large NodeIndex values quicker
 					// to avoid resizing the internal array too often
 					for ( int j = graphs.Length-1; j >= 0; j-- ) {
diff --git a/Assets/AstarPathfindingProject/Generators/Utilities/TileHandler.cs b/Assets/AstarPathfindingProject/Generators/Utilities/TileHandler.cs
index 492f882..a380988 100644
--- a/Assets/AstarPathfindingProject/Generators/Utilities/TileHandler.cs
+++ b/Assets/AstarPathfindingProject/Generators/Utilities/TileHandler.cs
@@ -269,7 +269,7 @@ namespace Pathfinding.Util
 			
 			isBatching = true;
 			
-			AstarPath.active.AddWorkItem(new AstarPath.AstarWorkItem (delegate (bool force) {
+			AstarPath.newActive.AddWorkItem(new AstarPath.AstarWorkItem (delegate (bool force) {
 				graph.StartBatchTileUpdate ();
 				return true;
 			}));
@@ -283,7 +283,7 @@ namespace Pathfinding.Util
 			for (int i=0;i<reloadedInBatch.Length;i++) reloadedInBatch[i] = false;
 			isBatching = false;
 			
-			AstarPath.active.AddWorkItem(new AstarPath.AstarWorkItem (delegate (bool force) {
+			AstarPath.newActive.AddWorkItem(new AstarPath.AstarWorkItem (delegate (bool force) {
 				
 				graph.EndBatchTileUpdate ();
 			
@@ -1154,11 +1154,11 @@ namespace Pathfinding.Util
 		
 		public void ClearTile (int x, int z) {
 			
-			if (AstarPath.active == null) return;
+			if (AstarPath.newActive == null) return;
 			
 			if ( x < 0 || z < 0 || x >= graph.tileXCount || z >= graph.tileZCount ) return;
 			
-			AstarPath.active.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
+			AstarPath.newActive.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
 				
 				//Replace the tile using the final vertices and triangles
 				graph.ReplaceTile(x,z,new Int3[0], new int[0], false);
@@ -1170,7 +1170,7 @@ namespace Pathfinding.Util
 				
 				//Flood fill everything to make sure graph areas are still valid
 				//This tends to take more than 50% of the calculation time
-				AstarPath.active.QueueWorkItemFloodFill();
+				AstarPath.newActive.QueueWorkItemFloodFill();
 				
 				/*if (!AstarPath.active.isScanning) {
 					
@@ -1290,7 +1290,7 @@ namespace Pathfinding.Util
 		public void LoadTile (TileType tile, int x, int z, int rotation, int yoffset) {
 			if (tile == null) throw new System.ArgumentNullException("tile");
 			
-			if (AstarPath.active == null) return;
+			if (AstarPath.newActive == null) return;
 			
 			int index = x + z*graph.tileXCount;
 			rotation = rotation % 4;
@@ -1311,7 +1311,7 @@ namespace Pathfinding.Util
 			//Add a work item
 			//This will pause pathfinding as soon as possible
 			//and call the delegate when it is safe to update graphs
-			AstarPath.active.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
+			AstarPath.newActive.AddWorkItem (new AstarPath.AstarWorkItem (delegate (bool force) {
 				
 				// If this was not the correct settings to load with, ignore
 				if ( !(activeTileOffsets[index] == yoffset && activeTileRotations[index] == rotation && activeTileTypes[index] == tile )) return true;
@@ -1377,7 +1377,7 @@ namespace Pathfinding.Util
 				
 				//Flood fill everything to make sure graph areas are still valid
 				//This tends to take more than 50% of the calculation time
-				AstarPath.active.QueueWorkItemFloodFill();
+				AstarPath.newActive.QueueWorkItemFloodFill();
 				
 				/*if (!AstarPath.active.isScanning && !wasBatching) {
 					//Flood fill everything to make sure graph areas are still valid
diff --git a/Assets/AstarPathfindingProject/Generators/Utilities/Voxels/DebugUtility.cs b/Assets/AstarPathfindingProject/Generators/Utilities/Voxels/DebugUtility.cs
index d7e8205..d72e260 100644
--- a/Assets/AstarPathfindingProject/Generators/Utilities/Voxels/DebugUtility.cs
+++ b/Assets/AstarPathfindingProject/Generators/Utilities/Voxels/DebugUtility.cs
@@ -13,7 +13,7 @@ namespace Pathfinding {
 #if UNITY_4_6 || UNITY_4_3
 		public static new DebugUtility active;
 #else
-		public static DebugUtility active;
+		public static DebugUtility newActive;
 #endif
 		
 		public float offset = 0.2F;
@@ -21,15 +21,15 @@ namespace Pathfinding {
 		public bool optimizeMeshes = false;
 		
 		public void Awake () {
-			active = this;
+			newActive = this;
 		}
 		
 		public static void DrawCubes (Vector3[] topVerts, Vector3[] bottomVerts, Color[] vertexColors, float width) {
 			
-			if (active == null) {
-				active = GameObject.FindObjectOfType(typeof(DebugUtility)) as DebugUtility;
+			if (newActive == null) {
+				newActive = GameObject.FindObjectOfType(typeof(DebugUtility)) as DebugUtility;
 			}
-			if (active == null) throw new System.NullReferenceException ();
+			if (newActive == null) throw new System.NullReferenceException ();
 			
 			if (topVerts.Length != bottomVerts.Length || topVerts.Length != vertexColors.Length) {
 				Debug.LogError ("Array Lengths are not the same");
@@ -72,8 +72,8 @@ namespace Pathfinding {
 			
 			for (int i=0;i<topVerts.Length;i++) {
 				
-				Vector3 top = topVerts[i] + new Vector3 (0,active.offset,0);
-				Vector3 bottom = bottomVerts[i] - new Vector3 (0,active.offset,0);;
+				Vector3 top = topVerts[i] + new Vector3 (0,newActive.offset,0);
+				Vector3 bottom = bottomVerts[i] - new Vector3 (0,newActive.offset,0);;
 				
 				Vector3 top1 = top + new Vector3 (-width,0,-width);
 				Vector3 top2 = top + new Vector3 (width,0,-width);
@@ -197,18 +197,18 @@ namespace Pathfinding {
 			mesh.triangles = tris;
 			mesh.colors = colors;
 			
-			mesh.name = "VoxelMesh";
+			mesh.newName = "VoxelMesh";
 			
 			mesh.RecalculateNormals ();
 			mesh.RecalculateBounds ();
 			
-			if (active.optimizeMeshes) {
+			if (newActive.optimizeMeshes) {
 				mesh.Optimize ();
 			}
 			
 			GameObject go = new GameObject ("DebugMesh");
 			MeshRenderer rend = go.AddComponent (typeof(MeshRenderer)) as MeshRenderer;
-			rend.material = active.defaultMaterial;
+			rend.material = newActive.defaultMaterial;
 			(go.AddComponent (typeof(MeshFilter)) as MeshFilter).mesh = mesh;
 		}
 		
@@ -264,7 +264,7 @@ namespace Pathfinding {
 			
 			GameObject go = new GameObject ("DebugMesh");
 			MeshRenderer rend = go.AddComponent (typeof(MeshRenderer)) as MeshRenderer;
-			rend.material = active.defaultMaterial;
+			rend.material = newActive.defaultMaterial;
 			(go.AddComponent (typeof(MeshFilter)) as MeshFilter).mesh = mesh;
 		}
 		
diff --git a/Assets/AstarPathfindingProject/Modifiers/RaycastModifier.cs b/Assets/AstarPathfindingProject/Modifiers/RaycastModifier.cs
index af49d49..3615fb3 100644
--- a/Assets/AstarPathfindingProject/Modifiers/RaycastModifier.cs
+++ b/Assets/AstarPathfindingProject/Modifiers/RaycastModifier.cs
@@ -196,8 +196,8 @@ namespace Pathfinding {
 			}
 			
 			if (useGraphRaycasting && n1 == null) {
-				n1 = AstarPath.active.GetNearest (v1).node;
-				n2 = AstarPath.active.GetNearest (v2).node;
+				n1 = AstarPath.newActive.GetNearest (v1).node;
+				n2 = AstarPath.newActive.GetNearest (v2).node;
 			}
 			
 			if (useGraphRaycasting && n1 != null && n2 != null) {
diff --git a/Assets/AstarPathfindingProject/Navmesh/NavmeshCut.cs b/Assets/AstarPathfindingProject/Navmesh/NavmeshCut.cs
index af074c8..8322fa2 100644
--- a/Assets/AstarPathfindingProject/Navmesh/NavmeshCut.cs
+++ b/Assets/AstarPathfindingProject/Navmesh/NavmeshCut.cs
@@ -248,7 +248,7 @@ namespace Pathfinding {
 						s = tmp;
 						
 						if (s == -1) {
-							Debug.LogError ("Invalid Mesh '"  + mesh.name + " in " + gameObject.name);
+							Debug.LogError ("Invalid Mesh '"  + mesh.newName + " in " + gameObject.newName);
 							break;
 						}
 					} while (s != i);
diff --git a/Assets/AstarPathfindingProject/Navmesh/TileHandlerHelper.cs b/Assets/AstarPathfindingProject/Navmesh/TileHandlerHelper.cs
index b6ea6f2..0cbc9b2 100644
--- a/Assets/AstarPathfindingProject/Navmesh/TileHandlerHelper.cs
+++ b/Assets/AstarPathfindingProject/Navmesh/TileHandlerHelper.cs
@@ -59,11 +59,11 @@ namespace Pathfinding {
 			}
 			
 			if (handler == null) {
-				if (AstarPath.active == null || AstarPath.active.astarData.recastGraph == null) {
+				if (AstarPath.newActive == null || AstarPath.newActive.astarData.recastGraph == null) {
 					Debug.LogWarning ("No AstarPath object in the scene or no RecastGraph on that AstarPath object");
 				}
 				
-				handler = new TileHandler(AstarPath.active.astarData.recastGraph);
+				handler = new TileHandler(AstarPath.newActive.astarData.recastGraph);
 				handler.CreateTileTypesFromGraph();
 			}
 	
diff --git a/Assets/AstarPathfindingProject/Pathfinders/ABPath.cs b/Assets/AstarPathfindingProject/Pathfinders/ABPath.cs
index 81742c6..e2e6680 100644
--- a/Assets/AstarPathfindingProject/Pathfinders/ABPath.cs
+++ b/Assets/AstarPathfindingProject/Pathfinders/ABPath.cs
@@ -186,7 +186,7 @@ namespace Pathfinding {
 			
 			//Initialize the NNConstraint
 			nnConstraint.tags = enabledTags;
-			NNInfo startNNInfo 	= AstarPath.active.GetNearest (startPoint,nnConstraint, startHint);
+			NNInfo startNNInfo 	= AstarPath.newActive.GetNearest (startPoint,nnConstraint, startHint);
 			
 			//Tell the NNConstraint which node was found as the start node if it is a PathNNConstraint and not a normal NNConstraint
 			PathNNConstraint pathNNConstraint = nnConstraint as PathNNConstraint;
@@ -202,7 +202,7 @@ namespace Pathfinding {
 			//If it is declared that this path type has an end point
 			//Some path types might want to use most of the ABPath code, but will not have an explicit end point at this stage
 			if (hasEndPoint) {
-				NNInfo endNNInfo = AstarPath.active.GetNearest (endPoint,nnConstraint, endHint);
+				NNInfo endNNInfo = AstarPath.newActive.GetNearest (endPoint,nnConstraint, endHint);
 				endPoint = endNNInfo.clampedPosition;
 				
 				// Note, other methods assume hTarget is (Int3)endPoint
diff --git a/Assets/AstarPathfindingProject/Pathfinders/ConstantPath.cs b/Assets/AstarPathfindingProject/Pathfinders/ConstantPath.cs
index 907699c..fb42435 100644
--- a/Assets/AstarPathfindingProject/Pathfinders/ConstantPath.cs
+++ b/Assets/AstarPathfindingProject/Pathfinders/ConstantPath.cs
@@ -119,7 +119,7 @@ mySeeker.StartPath (cpath,myCallbackFunction);
 		
 		public override void Prepare () {
 			nnConstraint.tags = enabledTags;
-			NNInfo startNNInfo 	= AstarPath.active.GetNearest (startPoint,nnConstraint);
+			NNInfo startNNInfo 	= AstarPath.newActive.GetNearest (startPoint,nnConstraint);
 			
 			startNode = startNNInfo.node;
 			if (startNode == null) {
diff --git a/Assets/AstarPathfindingProject/Pathfinders/FloodPath.cs b/Assets/AstarPathfindingProject/Pathfinders/FloodPath.cs
index 5723476..df67a2b 100644
--- a/Assets/AstarPathfindingProject/Pathfinders/FloodPath.cs
+++ b/Assets/AstarPathfindingProject/Pathfinders/FloodPath.cs
@@ -129,7 +129,7 @@ The easiest is to just modify the instance of PathIDConstraint which is created
 			if ( startNode == null ) {
 				//Initialize the NNConstraint
 				nnConstraint.tags = enabledTags;
-				NNInfo startNNInfo 	= AstarPath.active.GetNearest (originalStartPoint,nnConstraint);
+				NNInfo startNNInfo 	= AstarPath.newActive.GetNearest (originalStartPoint,nnConstraint);
 				
 				startPoint = startNNInfo.clampedPosition;
 				startNode = startNNInfo.node;
diff --git a/Assets/AstarPathfindingProject/Pathfinders/MultiTargetPath.cs b/Assets/AstarPathfindingProject/Pathfinders/MultiTargetPath.cs
index 53ea3d0..2290d37 100644
--- a/Assets/AstarPathfindingProject/Pathfinders/MultiTargetPath.cs
+++ b/Assets/AstarPathfindingProject/Pathfinders/MultiTargetPath.cs
@@ -320,7 +320,7 @@ namespace Pathfinding {
 		public override void Prepare () {
 			
 			nnConstraint.tags = enabledTags;
-			NNInfo startNNInfo 	= AstarPath.active.GetNearest (startPoint,nnConstraint, startHint);
+			NNInfo startNNInfo 	= AstarPath.newActive.GetNearest (startPoint,nnConstraint, startHint);
 			startNode = startNNInfo.node;
 			
 			if (startNode == null) {
@@ -352,7 +352,7 @@ namespace Pathfinding {
 			bool anyNotNull = false;
 			
 			for (int i=0;i<targetPoints.Length;i++) {
-				NNInfo endNNInfo = AstarPath.active.GetNearest (targetPoints[i],nnConstraint);
+				NNInfo endNNInfo = AstarPath.newActive.GetNearest (targetPoints[i],nnConstraint);
 				
 				targetNodes[i] = endNNInfo.node;
 				//Debug.DrawLine (targetPoints[i],targetNodes[i].position,Color.red);
diff --git a/Assets/AstarPathfindingProject/Pathfinders/RandomPath.cs b/Assets/AstarPathfindingProject/Pathfinders/RandomPath.cs
index 25a05ad..a9abc11 100644
--- a/Assets/AstarPathfindingProject/Pathfinders/RandomPath.cs
+++ b/Assets/AstarPathfindingProject/Pathfinders/RandomPath.cs
@@ -132,7 +132,7 @@ seeker.StartPath (path,MyCompleteFunction);
 		public override void Prepare () {
 			
 			nnConstraint.tags = enabledTags;
-			NNInfo startNNInfo 	= AstarPath.active.GetNearest (startPoint,nnConstraint, startHint);
+			NNInfo startNNInfo 	= AstarPath.newActive.GetNearest (startPoint,nnConstraint, startHint);
 			
 			startPoint = startNNInfo.clampedPosition;
 			endPoint = startPoint;
diff --git a/Assets/AstarPathfindingProject/RVO/RVONavmesh.cs b/Assets/AstarPathfindingProject/RVO/RVONavmesh.cs
index 2886566..22f57c1 100644
--- a/Assets/AstarPathfindingProject/RVO/RVONavmesh.cs
+++ b/Assets/AstarPathfindingProject/RVO/RVONavmesh.cs
@@ -42,7 +42,7 @@ namespace Pathfinding.RVO {
 			
 			RemoveObstacles ();
 			
-			NavGraph[] graphs = AstarPath.active.graphs;
+			NavGraph[] graphs = AstarPath.newActive.graphs;
 			
 			RVOSimulator rvosim = FindObjectOfType(typeof(RVOSimulator)) as RVOSimulator;
 			if (rvosim == null) throw new System.NullReferenceException ("No RVOSimulator could be found in the scene. Please add one to any GameObject");
diff --git a/Assets/AstarPathfindingProject/Utilities/GraphUpdateUtilities.cs b/Assets/AstarPathfindingProject/Utilities/GraphUpdateUtilities.cs
index 8e24969..a9a3bd8 100644
--- a/Assets/AstarPathfindingProject/Utilities/GraphUpdateUtilities.cs
+++ b/Assets/AstarPathfindingProject/Utilities/GraphUpdateUtilities.cs
@@ -93,13 +93,13 @@ namespace Pathfinding {
 			
 			AstarPath.RegisterSafeUpdate (delegate () {
 				
-				AstarPath.active.UpdateGraphs (guo);
+				AstarPath.newActive.UpdateGraphs (guo);
 				
 				//Make sure graph updates are registered for update and not delayed for performance
-				AstarPath.active.QueueGraphUpdates ();
+				AstarPath.newActive.QueueGraphUpdates ();
 				
 				//Call thread safe callbacks, includes graph updates
-				AstarPath.active.FlushGraphUpdates();
+				AstarPath.newActive.FlushGraphUpdates();
 				
 				//Check if all nodes are in the same area and that they are walkable, i.e that there are paths between all of them
 				worked = worked && PathUtilities.IsPathPossible (nodes);
@@ -109,12 +109,12 @@ namespace Pathfinding {
 					guo.RevertFromBackup ();
 					
 					//The revert operation does not revert ALL nodes' area values, so we must flood fill again
-					AstarPath.active.FloodFill ();
+					AstarPath.newActive.FloodFill ();
 				}
 			});
 			
 			//Force the thread safe callback to be called
-			AstarPath.active.FlushThreadSafeCallbacks();
+			AstarPath.newActive.FlushThreadSafeCallbacks();
 			
 			//Disable tracking nodes, not strictly necessary, but will slightly reduce the cance that some user causes errors
 			guo.trackChangedNodes = false;
